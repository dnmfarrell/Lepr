#!/usr/bin/perl
use v5.16;
use warnings;

our $ENV = {
  print => sub { say @_ },
  head  => sub { shift @_ },
  join  => sub { my $str = shift; join $str, @_ },
  tail  => sub { shift @_; @_ },
  map   => sub { my $fun = shift; map { $fun->($_) } @_ },
  '+'   => sub { my $n = shift; $n += $_ for @_; $n },
  '-'   => sub { my $n = shift; $n -= $_ for @_; $n },
  '/'   => sub { my $n = shift; $n /= $_ for @_; $n },
  '*'   => sub { my $n = shift; $n *= $_ for @_; $n },
  '^'   => sub { my $n = shift; $n**= $_ for @_; $n },
};
run(@ARGV);

sub tokenize {
  my $chars = shift;
  $chars =~ s{\(}{( }g;
  $chars =~ s{\)}{ )}g;
  [ split /\s+/, $chars ]}

sub parse {
  my $t = shift @{$_[0]};
  if    (!defined $t || $t eq ')') { () }
  elsif ($t eq '(')                { [ parse(@_) ], parse(@_) }
  else                             { $t, parse(@_) }}

sub evaluate {
  my ($expr, $env) = @_;
  my $op = shift @$expr;
  if (!defined $op) {
    ();
  } elsif (ref $op eq 'ARRAY') {
    evaluate($op, $env), evaluate($expr, $env);
  } elsif ($op eq 'macro') {
    my $name = shift @$expr;
    $env->{"macro $name"} = fun($expr, $env);
    ();
  } elsif ($op eq 'fun') {
    fun($expr, $env);
  } elsif ($op eq 'if') {
    my ($cond, $then) = splice @$expr, 0, 2;
    $cond = evaluate($cond, $env) if ref $cond;
    if ($cond) { evaluate($then, $env) }
    elsif (my $else = shift @$expr) { evaluate($else, $env) }
    ()
  } elsif ($op eq 'call') {
    my ($fun, @args) = evaluate($expr, $env);
    $fun->(@args);
  } elsif ($op eq 'set') {
    my $name = shift @$expr;
    $env->{$name} = $expr;
    ();
  } elsif (my $macro = find("macro $op", $env)) {
    $macro->(@$expr);
  } elsif (my $symbol = find($op, $env)) {
    if (ref $symbol eq 'CODE') {
      $symbol->(evaluate($expr, $env));
    } elsif (ref $symbol eq 'ARRAY') {
      evaluate($symbol, $env), evaluate($expr, $env);
    } else {
      $symbol, evaluate($expr, $env);
    }
  } else {
    $op, evaluate($expr, $env);
  }}

sub fun {
  my ($expr, $env) = @_;
  my ($params, $body) = splice @$expr, 0;
  sub {
    my %scope = map { $params->[$_] => $_[$_] } 0 .. $#$params;
    $scope{OUTER} = $env;
    evaluate([@$body], \%scope);
  }}

sub find {
  my ($k, $env) = @_;
  if    (my $v = $env->{$k})        { $v }
  elsif (my $outer = $env->{OUTER}) { find($k, $outer) }}

sub run {
  my ($code) = @_;
  my $tokens = tokenize($code);
  my @ast = parse([@$tokens]);
  evaluate(\@ast, $ENV)}
