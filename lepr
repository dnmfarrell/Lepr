#!/usr/bin/perl
use Data::Dumper;
use List::Util qw(all);
use Storable qw(dclone);
use v5.16;
use warnings;

our $ENV = {
  print => sub { say @_ },
  split => sub { my $s = shift;split /$s/, join '', @_ },
  dump  => sub { print Dumper(\@_) },
  grep  => sub { my $f = shift; grep { $f->($_) } @_ },
  head  => sub { shift @_ },
  join  => sub { my $s = shift; join $s, @_ },
  sort  => sub { sort @_ },
  tail  => sub { @_[1..$#_] },
  map   => sub { my $f = shift; map { $f->($_) } @_ },
  eq    => sub { my $s = shift; all { $s eq $_ } @_ },
  '=='  => sub { my $n = shift; all { $n == $_ } @_ },
  '>='  => sub { my $n = shift; all { $n >= $_ } @_ },
  '<='  => sub { my $n = shift; all { $n <= $_ } @_ },
  '>'   => sub { my $n = shift; all { $n > $_ } @_ },
  '<'   => sub { my $n = shift; all { $n < $_ } @_ },
  '+'   => sub { my $n = shift; $n += $_ for @_; $n },
  '-'   => sub { my $n = shift; $n -= $_ for @_; $n },
  '/'   => sub { my $n = shift; $n /= $_ for @_; $n },
  '*'   => sub { my $n = shift; $n *= $_ for @_; $n },
  '^'   => sub { my $n = shift; $n**= $_ for @_; $n },
  '!'   => sub { map { !$_ } @_ },
};
run(join ' ', @ARGV);

sub tokenize {
  my @chars = split //, shift;
  my ($t, @tokens) = ('');
  while (defined(my $c = shift @chars)) {
    if ($c eq '"') {
      push @tokens, $t if $t; $t = '';
      while (defined($c = shift @chars)) {
        if ($c eq '"') { push @tokens, $t; $t = ''; last }
        else { $t .= $c }}
    }
    elsif ($c =~ /\s/)   { push @tokens, $t if length $t; $t = '' }
    elsif ($c =~ /[()]/) { push @tokens, $t if length $t; $t = ''; push @tokens, $c }
    else                 { $t .= $c }
  }
  \@tokens }

sub parse {
  my $t = shift @{$_[0]};
  if    (!defined $t || $t eq ')') { () }
  elsif ($t eq '(')                { [ parse(@_) ], parse(@_) }
  else                             { $t, parse(@_) }}

sub evaluate {
  my ($expr, $env) = @_;
  my $op = shift @$expr;
  if (!defined $op) {
    ();
  } elsif (ref $op eq 'ARRAY') {
    evaluate($op, $env), evaluate($expr, $env);
  } elsif ($op eq 'nil') {
    undef, evaluate($expr, $env);
  } elsif ($op eq 'macro') {
    my $name = shift @$expr;
    $env->{"macro $name"} = fun($expr, $env);
    ();
  } elsif ($op eq 'fun') {
    if (ref $expr->[0]) { # anonymous fun
      fun($expr, $env)
    } else {
      my $fun_name = shift @$expr;
      $env->{$fun_name} = fun($expr, $env);
    }
  } elsif ($op eq 'if') {
    my ($cond, $then) = splice @$expr, 0, 2;
    ($cond) = evaluate([$cond], $env); # always eval in list context
    if (defined $cond) { evaluate([$then], $env) }
    elsif (my $else = shift @$expr) { evaluate([$else], $env) }
    else {
      ()
    }
  } elsif ($op eq 'call') {
    my ($fun, @args) = evaluate($expr, $env);
    $fun->(@args);
  } elsif ($op eq 'set') {
    my %pairs = @$expr;
    $env->{$_} = $pairs{$_} for keys %pairs; # lazy
    ();
  } elsif (my $macro = find("macro $op", $env)) {
    $macro->(@$expr);
  } elsif (exist($op, $env)) {
    my $symbol = find($op, $env);
    if (ref $symbol eq 'CODE') {
      $symbol->(evaluate($expr, $env));
    } elsif (ref $symbol eq 'ARRAY') {
      evaluate(dclone($symbol), $env), evaluate($expr, $env);
    } else {
      $symbol, evaluate($expr, $env);
    }
  } else {
    $op, evaluate($expr, $env);
  }}

sub fun {
  my ($expr, $env) = @_;
  my @params = evaluate(shift @$expr, $env);
  my $body = $expr;
  sub {
    my (@args, %scope) = @_;
    for my $p (@params) {
      if (substr($p, 0, 1) eq '@') { #list param
        my $new_p = substr $p, 1;
        $scope{$new_p} = [splice @args, 0];
      }
      else {
        $scope{$p} = shift @args;
      }
    }
    $scope{OUTER} = $env;
    evaluate(dclone($body), \%scope);
  }}

sub find {
  my ($k, $env) = @_;
  if (defined (my $v = $env->{$k})) { $v }
  elsif (my $outer = $env->{OUTER}) { find($k, $outer) }}

sub exist {
  my ($k, $env) = @_;
  if    (exists $env->{$k})         { 1 }
  elsif (my $outer = $env->{OUTER}) { exist($k, $outer) }}

sub run {
  my ($code) = @_;
  my $tokens = tokenize($code);
  my @ast = parse([@$tokens]);
  evaluate(\@ast, $ENV)}
